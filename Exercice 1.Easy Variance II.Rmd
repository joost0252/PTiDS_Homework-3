---
title: "homework-3 - Exercice 1.Easy variance II"
author: "Amina Mohammed (17301920)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r, echo = FALSE, include = FALSE, message = FALSE}
source(here::here("Setup.R"))
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### Problem statement

The bootstrap is a straightforward method for estimating quantities for a statistic such as an estimator of its variance. 


#### Exercise Solving


1. Using your most efficient implementation of the bootstrap from the previous homework, write a function named `bootstrap` with arguments `x` for a vector of sample data, `B` for the number of bootstrapped samples with default values `1000L` and `statistic` for a generic function to be passed. The function must return a list with the statistic evaluated on the sample `x`, say `theta_hat`, on the bootstrapped samples, say `theta_star`, and an estimate of the variance of the statistic, say `varBoot`.

```{r echo = FALSE, include = FALSE, message = FALSE}

#turn on set.seed() if you want the results not to vary
set.seed(626)

B = 1000L                                  #  Number of bootstrapped samples with default values 1000L
Statistic <- as.list(c("var", "mean"))

# Bootstrap with a for loop 
 
  
Bootstrap <- function(data, B, Statistic) {
  thêta_hat<- rep(0,B)
  thêta_star <- rep(0,B)
  
  if (Statistic == "var") {
    
     # for the bootstrap estimate : list with the statistic evaluated on the sample x
  for (i in 1:B) {
  thêta_hat[i] <- var(sample(data, replace = TRUE))                    
  }
  
   # for the bootstrap estimate : on the bootstrapped samples (on têta_hat)
  for (i in 1:B) {
  thêta_star[i] <- var(sample(thêta_hat, replace = TRUE))                    
  }
  
  # for varBoot
  n <- as.numeric (length(thêta_hat))
  varBoot <- as.numeric (var(thêta_hat) *  ((n - 1) / n))
  
  # for the output
  my_return <- list("thêta_hat" = thêta_hat, "theta_star" = thêta_star, "varBoot" = varBoot)
  return(my_return) 
  }
  
   if (Statistic == "mean") {
      # for the bootstrap estimate : list with the statistic evaluated on the sample x
  for (i in 1:B) {
  thêta_hat[i] <- mean(sample(data, replace = TRUE))                    
  }
  
   # for the bootstrap estimate : on the bootstrapped samples (on têta_hat)
  for (i in 1:B) {
  thêta_star[i] <- mean(sample(thêta_hat, replace = TRUE))                    
  }
  
  # for varBoot
  n <- as.numeric (length(thêta_hat))
  varBoot <- as.numeric (mean(thêta_hat) *  ((n - 1) / n))
  
  # for the output
  my_return <- list("thêta_hat" = thêta_hat, "theta_star" = thêta_star, "varBoot" = varBoot)
  return(my_return) 
   }
}
```


2.  Simulate a sample of size $10^4$ from a $t$-distribution with $\nu=3$ degrees of freedom (when $\nu\to\infty$, then the $t$-distribution tends to a standard normal distribution). Using the base R variance `var` as the `statistic`, compute the $B=1,000$ bootstrapped statistics using your function for subsamples of size $100$, $1,000$ and the full sample that you generated, and make three boxplots in one graph. The true variance is given by $\nu/(\nu-2)$. Illustrate it in your graph and comment what has been obtained. Does it illustrate some concepts in statistics or probability theory?

```{r echo = FALSE, include = FALSE, message = FALSE}

# for the sample of size $10^4$ from a $t$-distribution with $\nu=3$ degrees of freedom

samplesize <- 1:10^4                                                    #size of the sample
mydata <- dt(samplesize, df = 3)                                        # data we will boostrap 

# Bootstraping in full sample
full_sample <- Bootstrap(data = mydata, B = 1000L, Statistic = var)
plot_full <- ggplot(as.data.frame(full_sample), aes(y=thêta_hat)) + 
  geom_boxplot(notch=TRUE) 
#+ 
  #geom_hline(yintercept = full_sample$varBoot)
#+ geom_hline(yintercept=true_variance, color= "red")

# Subsample for size 100

Subsample_100 <- dt((1:100), df = 3)   
boostrap_Subsample_100 <- Bootstrap(data = Subsample_100, B = 1000L, Statistic = var)
plot_100 <- ggplot(as.data.frame(boostrap_Subsample_100), aes(y=thêta_hat)) + 
  geom_boxplot(notch=TRUE) 
#+ geom_hline(yintercept=true_variance, color= "red")

# Subsample for size 1

Subsample_1 <- dt((1), df = 3)   
boostrap_Subsample_1 <- Bootstrap(data = Subsample_1, B = 1000L, Statistic = var)
plot_1 <- ggplot(as.data.frame(boostrap_Subsample_1), aes(y=thêta_hat)) + 
  geom_boxplot(notch=TRUE) 
#+ geom_hline(yintercept=true_variance, color= "red")

# Subsample for size 100

Subsample_000 <- dt((000), df = 3)   
boostrap_Subsample_000 <- Bootstrap(data = Subsample_000, B = 1000L, Statistic = var)
plot_000 <- ggplot(as.data.frame(boostrap_Subsample_000), aes(y=thêta_hat)) + 
  geom_boxplot(notch=TRUE) 
#+ geom_hline(yintercept=true_variance, color= "red")

# Compute the true variance
v = (3-1)
true_variance <- (v/(v-2))

library(ggplot2)
library(gridExtra)

```

```{r, message = FALSE}
grid.arrange(plot_full, plot_100,plot_1,plot_000,  nrow = 1)
```

3.  Take the one of the subsample of 2., and compare the performances between your implementation of `bootstrap` with the function bootstrap from the bootstrap package (installation required). Make sure the comparison is as fair as possible (same number of bootstrap samples, ...).

```{r, message = FALSE}
#compare the performances 

set.seed(626)

profvis::profvis({
  # Profiling boostrap_Subsample_100
Subsample_100 <- dt((1:100), df = 3)   
boostrap_Subsample_100 <- Bootstrap(data = Subsample_100, B = 1000L, Statistic = var)

  })
```

```{r, message = FALSE}
  # Profiling Bootstrap with bootstrap package from R
set.seed(626)
profvis::profvis({
  
boot(mydata, statistic = var, R=1000L)
  })
```
<br>
<br>
4.  Load `test1.rds` and make this call `bootstrap(a, statistic = mean)`. The call must returns the following error:
```{r echo = FALSE, include = FALSE, message = FALSE}

library(rstan)
test1 <- readRDS("~/Desktop/GitHub/homework-3-group_f/test1.rds")
typeof(test1)
call(test1)

```

```{r echo = FALSE, include = FALSE, message = FALSE}
# add to Error and Warning message 
Bootstrap <- function(data, B, Statistic) {
  
  # Error and Warning message 
  if (typeof(data) == "character") {
      stop(" 'x' must be numeric")
  }
  
  # Code if everything is okay
  else {
    
    thêta_hat<- rep(0,B)
    thêta_star <- rep(0,B)
    
  if (Statistic == "var") {
    
     # for the bootstrap estimate : list with the statistic evaluated on the sample x
  for (i in 1:B) {
  thêta_hat[i] <- var(sample(data, replace = TRUE))                    
  }
  
   # for the bootstrap estimate : on the bootstrapped samples (on têta_hat)
  for (i in 1:B) {
  thêta_star[i] <- var(sample(thêta_hat, replace = TRUE))                    
  }
  
  # for varBoot
  n <- as.numeric (length(thêta_hat))
  varBoot <- as.numeric (var(thêta_hat) *  ((n - 1) / n))
  
  # for the output
  my_return <- list("thêta_hat" = thêta_hat, "theta_star" = thêta_star, "varBoot" = varBoot)
  return(my_return) 
  }
  
   if (Statistic == "mean") {
      # for the bootstrap estimate : list with the statistic evaluated on the sample x
  for (i in 1:B) {
  thêta_hat[i] <- mean(sample(data, replace = TRUE))                    
  }
  
   # for the bootstrap estimate : on the bootstrapped samples (on têta_hat)
  for (i in 1:B) {
  thêta_star[i] <- mean(sample(thêta_hat, replace = TRUE))                    
  }
  
  # for varBoot
  n <- as.numeric (length(thêta_hat))
  varBoot <- as.numeric (mean(thêta_hat) *  ((n - 1) / n))
  
  # for the output
  my_return <- list("thêta_hat" = thêta_hat, "theta_star" = thêta_star, "varBoot" = varBoot)
  return(my_return) 
   }
  }
}

```
Adapt your implementation until this error message shows.

```{r, error=TRUE}
# Bootstrap(a, statistic = mean)
Bootstrap(data = a , B = 1000L, Statistic = mean)
```

5. Load `test2.rds` and execute `bootstrap(M, statistic = mean)`. The call must returns the following warning:
```{r echo = FALSE, include = FALSE, message = FALSE}
library(rstan)
test2 <- load("~/Desktop/GitHub/homework-3-group_f/test2.rds")
typeof(test2)

call(test2)

```

```{r echo = FALSE, include = FALSE, message = FALSE}
# add to Error and Warning message
Bootstrap <- function(data, B, Statistic) {
  
  # Error and Warning message 
  if (typeof(data) == "character") {
    data <- as.vector(data)
    warning(" 'x' has been coerced to a vector")
  }
  
  # Code if everything is okay
  
    thêta_hat<- rep(0,B)
    thêta_star <- rep(0,B)
    
  if (Statistic == "var") {
    
     # for the bootstrap estimate : list with the statistic evaluated on the sample x
  for (i in 1:B) {
  thêta_hat[i] <- var(sample(data, replace = TRUE))                    
  }
  
   # for the bootstrap estimate : on the bootstrapped samples (on têta_hat)
  for (i in 1:B) {
  thêta_star[i] <- var(sample(thêta_hat, replace = TRUE))                    
  }
  
  # for varBoot
  n <- as.numeric (length(thêta_hat))
  varBoot <- as.numeric (var(thêta_hat) *  ((n - 1) / n))
  
  # for the output
  my_return <- list("thêta_hat" = thêta_hat, "theta_star" = thêta_star, "varBoot" = varBoot)
  return(my_return) 
  }
  
   if (Statistic == "mean") {
      # for the bootstrap estimate : list with the statistic evaluated on the sample x
  for (i in 1:B) {
  thêta_hat[i] <- mean(sample(data, replace = TRUE))                    
  }
  
   # for the bootstrap estimate : on the bootstrapped samples (on têta_hat)
  for (i in 1:B) {
  thêta_star[i] <- mean(sample(thêta_hat, replace = TRUE))                    
  }
  
  # for varBoot
  n <- as.numeric (length(thêta_hat))
  varBoot <- as.numeric (mean(thêta_hat) *  ((n - 1) / n))
  
  # for the output
  my_return <- list("thêta_hat" = thêta_hat, "theta_star" = thêta_star, "varBoot" = varBoot)
  return(my_return) 
   }
  }
```
it means that `M` is treated as a vector (dim is NULL). Modify your implementation in order to coerce `M` to a vector and show the above warning once the coercion happens.

```{r, error=TRUE}
Bootstrap(M,B = 1000L, Statistic = mean)
```

6. Modify your implementation of `bootstrap` so `bootstrap(M, B="a", statistic = mean)` shows the following error

```{r echo = FALSE, include = FALSE, message = FALSE}

#Error in bootstrap(M, B = "a", statistic = mean) : 'B' must be numeric
# add to Error and Warning message 
Bootstrap <- function(data, B, Statistic) {
  
  # Error and Warning message 
  if (typeof(B) != "numeric") {
      stop(" 'B' must be numeric")
  }
  
  # Code if everything is okay
  else {
    thêta_hat <- rep(0,B)
    thêta_star <- rep(0,B)
  
  if (Statistic == "var") {
    
     # for the bootstrap estimate : list with the statistic evaluated on the sample x
  for (i in 1:B) {
  thêta_hat[i] <- var(sample(data, replace = TRUE))                    
  }
  
   # for the bootstrap estimate : on the bootstrapped samples (on têta_hat)
  for (i in 1:B) {
  thêta_star[i] <- var(sample(thêta_hat, replace = TRUE))                    
  }
  
  # for varBoot
  n <- as.numeric (length(thêta_hat))
  varBoot <- as.numeric (var(thêta_hat) *  ((n - 1) / n))
  
  # for the output
  my_return <- list("thêta_hat" = thêta_hat, "theta_star" = thêta_star, "varBoot" = varBoot)
  return(my_return) 
  }
  
   if (Statistic == "mean") {
      # for the bootstrap estimate : list with the statistic evaluated on the sample x
  for (i in 1:B) {
  thêta_hat[i] <- mean(sample(data, replace = TRUE))                    
  }
  
   # for the bootstrap estimate : on the bootstrapped samples (on têta_hat)
  for (i in 1:B) {
  thêta_star[i] <- mean(sample(thêta_hat, replace = TRUE))                    
  }
  
  # for varBoot
  n <- as.numeric (length(thêta_hat))
  varBoot <- as.numeric (mean(thêta_hat) *  ((n - 1) / n))
  
  # for the output
  my_return <- list("thêta_hat" = thêta_hat, "theta_star" = thêta_star, "varBoot" = varBoot)
  return(my_return) 
   }
  }
}
```

```{r, error=TRUE}
Bootstrap(M, B = "a", Statistic = mean)
```

7. Modify your implementation of `bootstrap` so `bootstrap(M, statistic = "mean")` shows the following error


```{r echo = FALSE, include = FALSE, message = FALSE}
#Error in bootstrap(M, statistic = "mean"") : 'statistic' must be a function
#add to Error and Warning message section

Bootstrap <- function(data, B, Statistic) {
  
  # Error and Warning message 
  
  if (Statistic != "var" | Statistic != "mean" ) {
      stop(" 'statistic' must be a function")
  }
  
  # Code if everything is okay
  else {
    
    thêta_hat<- rep(0,B)
    thêta_star <- rep(0,B)
    
  if (Statistic == "var") {
    
     # for the bootstrap estimate : list with the statistic evaluated on the sample x
  for (i in 1:B) {
  thêta_hat[i] <- var(sample(data, replace = TRUE))                    
  }
  
   # for the bootstrap estimate : on the bootstrapped samples (on têta_hat)
  for (i in 1:B) {
  thêta_star[i] <- var(sample(thêta_hat, replace = TRUE))                    
  }
  
  # for varBoot
  n <- as.numeric (length(thêta_hat))
  varBoot <- as.numeric (var(thêta_hat) *  ((n - 1) / n))
  
  # for the output
  my_return <- list("thêta_hat" = thêta_hat, "theta_star" = thêta_star, "varBoot" = varBoot)
  return(my_return) 
  }
  
   if (Statistic == "mean") {
      # for the bootstrap estimate : list with the statistic evaluated on the sample x
  for (i in 1:B) {
  thêta_hat[i] <- mean(sample(data, replace = TRUE))                    
  }
  
   # for the bootstrap estimate : on the bootstrapped samples (on têta_hat)
  for (i in 1:B) {
  thêta_star[i] <- mean(sample(thêta_hat, replace = TRUE))                    
  }
  
  # for varBoot
  n <- as.numeric (length(thêta_hat))
  varBoot <- as.numeric (mean(thêta_hat) *  ((n - 1) / n))
  
  # for the output
  my_return <- list("thêta_hat" = thêta_hat, "theta_star" = thêta_star, "varBoot" = varBoot)
  return(my_return) 
   }
  }
}
```

```{r, error=TRUE}
Bootstrap(mydata, B = 1000L, Statistic = "mean")
```
8. Load `test3.rds` and see what happens when executing `bootstrap(m, statistic = mean)`. Remove any missing value from `m` and re-run the function calls. Removing missing values should happen within the function calls. The function `mean` has an argument for removing missing values, namely `mean(m, na.rm=TRUE)`. You are to exploit that, but `bootstrap(m, statistic = mean(na.rm = TRUE))` does not work (try it).  Modify your implementation by using `...` as an argument in order for `bootstrap(m, statistic = mean, na.rm = TRUE)` to return the expected results.

```{r }
library(rstan)
test3 <- load("~/Desktop/GitHub/homework-3-group_f/test3.rds")
typeof(test3)

call(test3)


```

```{r}
Bootstrap <- function(data, B, Statistic, na.rm) {
  
  if (na.rm == TRUE) {
    na.omit(data)
  }
  
  # Code if everything is okay
  else {
    
    thêta_hat<- rep(0,B)
    thêta_star <- rep(0,B)
    
  if (Statistic == "var") {
    
     # for the bootstrap estimate : list with the statistic evaluated on the sample x
  for (i in 1:B) {
  thêta_hat[i] <- var(sample(data, replace = TRUE))                    
  }
  
   # for the bootstrap estimate : on the bootstrapped samples (on têta_hat)
  for (i in 1:B) {
  thêta_star[i] <- var(sample(thêta_hat, replace = TRUE))                    
  }
  
  # for varBoot
  n <- as.numeric (length(thêta_hat))
  varBoot <- as.numeric (var(thêta_hat) *  ((n - 1) / n))
  
  # for the output
  my_return <- list("thêta_hat" = thêta_hat, "theta_star" = thêta_star, "varBoot" = varBoot)
  return(my_return) 
  }
  
   if (Statistic == "mean") {
      # for the bootstrap estimate : list with the statistic evaluated on the sample x
  for (i in 1:B) {
  thêta_hat[i] <- mean(sample(data, replace = TRUE))                    
  }
  
   # for the bootstrap estimate : on the bootstrapped samples (on têta_hat)
  for (i in 1:B) {
  thêta_star[i] <- mean(sample(thêta_hat, replace = TRUE))                    
  }
  
  # for varBoot
  n <- as.numeric (length(thêta_hat))
  varBoot <- as.numeric (mean(thêta_hat) *  ((n - 1) / n))
  
  # for the output
  my_return <- list("thêta_hat" = thêta_hat, "theta_star" = thêta_star, "varBoot" = varBoot)
  return(my_return) 
   }
  }
}

```

```{r}
Bootstrap(m, B = 1000L, Statistic = mean, na.rm = TRUE)
```
